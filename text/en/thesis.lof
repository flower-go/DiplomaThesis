\addvspace {10\p@ }
\contentsline {figure}{\numberline {1.1}{\ignorespaces An example of the syntax and dependency tree. The dependency tree, as the name indicates, describes dependencies between words. Such dependencies are of various types; for example, an elephant in the example text is a direct object of the shooting action. A root of such a tree is typically a predicate of the sentence. On the other hand, the syntax tree represents the sentence's syntactic structure according to the grammar. The root of the tree is \textit {sentence}, which is split into noun and verb phrase. These can be further divided into phrases compound from particular instances of parts of speech (e.g., nouns, adverbs, verbs, prepositions, etc.). \newline \textit {Source: \cite {NLTKbook}}}}{6}{figure.1.1}% 
\contentsline {figure}{\numberline {1.2}{\ignorespaces Prague dependency treebank example \cite {PDT35} for the sentences: \textit {Grasshoppers are still in the larvae stadium, crawling only. At this time of the year, it is efficient to fight them using chemicals, but neither the ailing cooperatives nor private farmers can afford them.} czech: \textit {Saran\IeC {\v c}ata jsou doposud ve stadiu larev a pohybuj\IeC {\'\i } se pouze lezen\IeC {\'\i }m. V tomto obdob\IeC {\'\i } je \IeC {\'u}\IeC {\v c}inn\IeC {\'e} bojovat proti nim chemick\IeC {\'y}mi post\IeC {\v r}iky, ale do\IeC {\v z}\IeC {\'\i }vaj\IeC {\'\i }c\IeC {\'\i } dru\IeC {\v z}stva ani soukrom\IeC {\'\i } roln\IeC {\'\i }ci nemaj\IeC {\'\i } na jejich n\IeC {\'a}kup pot\IeC {\v r}ebn\IeC {\'e} prost\IeC {\v r}edky}. This treebank contains dependency trees, but is is just one of many possibilities. This example is from Prague dependency treebank, which offers different layers of annotations. Red strips over words \textit {chemick\IeC {\'y}} and \textit {post\IeC {\v r}ik} marks multiword phrase, conjunction between \textit {roln\IeC {\'\i }k} and \textit {dru\IeC {\v z}stvo} is expressed as by one type of nodes, blue lines denotes coreference etc.}}{7}{figure.1.2}% 
\contentsline {figure}{\numberline {1.3}{\ignorespaces A one-layer perceptron architecture. The result is formed by the application of the activation function on a weighted sum of inputs. Weights are updated during training till it returns satisfactory results. }}{9}{figure.1.3}% 
\contentsline {figure}{\numberline {1.4}{\ignorespaces This picture illustrates XOR problem. Perception can find the correct solution only if the data are linearly separable. It means that they can be divided by a hyperplane. An example of such two-dimensional data can be seen in picture A). The dotted line shows a possible border for separation. Picture B) shows XOR problem. XOR is a logical operation on two boolean variables, which returns true if one variable is True (1) and the other one is False (0), and returns False otherwise. Such data cannot be separated by one hyperplane. Linearly non-separable data can be, for example, separated by a circle (pic. C)}}{9}{figure.1.4}% 
\contentsline {figure}{\numberline {1.5}{\ignorespaces Multilayer perceptron (or feed-forward neural network) is formed input and output layer and a variable number of hidden layers with different sizes. In every layer, the chosen application function is applied to a weighted sum of inputs from the previous layer.}}{10}{figure.1.5}% 
\contentsline {figure}{\numberline {1.6}{\ignorespaces Figure A) presents overfitting scenario. Figure B) illustrates possible well-generalized solution. }}{12}{figure.1.6}% 
\contentsline {figure}{\numberline {1.7}{\ignorespaces Figure 3 of \citep {Bahdanau} }}{14}{figure.1.7}% 
\contentsline {figure}{\numberline {1.8}{\ignorespaces Figure 3 of \citep {Santos2016} }}{15}{figure.1.8}% 
\contentsline {figure}{\numberline {1.9}{\ignorespaces Self-attention mechanism scheme for one concrete query vector. The result is an embedding, which is improved by the context of the word. This picture illustrates the result for the embedding of the first word (l1) in a four-word long text. Keys, values, and a query are all multiplied by their respective weights ($W_k$, $W_v$, and $W_q$) before any other operation with them. These weights are trained during learning. Dot products between every word and a query are computed. A result is a number for every input word, so four numbers at the end. These numbers are normalized, so the sum of them is equal to 1. These words serve as a weight ($M_x$), which indicates the relationship between the query and every other word. The resulting better embedding for the query is then obtained as a sum of the word embeddings weighted by these obtained weights. }}{16}{figure.1.9}% 
\contentsline {figure}{\numberline {1.10}{\ignorespaces Figure 2 from \citep {Vaswani2017}. }}{17}{figure.1.10}% 
\contentsline {figure}{\numberline {1.11}{\ignorespaces Basic Recurent neural network architecture. It is composed by one rnn cell which recurrently uses informations from previous seen input. For better illustration of working in the time, RNN can be visualised as a chain of cells connected by a result of previous cell. source: \textit {Picture from https://medium.com/deeplearningbrasilia/deep-learning-recurrent-neural-networks-f9482a24d010}.}}{18}{figure.1.11}% 
\contentsline {figure}{\numberline {1.12}{\ignorespaces Comparison of LSTM and GRU architecture \textit {http://dprogrammer.org/rnn-lstm-gru}.}}{18}{figure.1.12}% 
\contentsline {figure}{\numberline {1.13}{\ignorespaces This picture describes design of one transformers layer. source: http://jalammar.github.io/illustrated-transformer }}{19}{figure.1.13}% 
\contentsline {figure}{\numberline {1.14}{\ignorespaces In transformers, encoder and decoder parts are both composed by many of block of respective types. The input goes first through a series of encoders and than the output of encoder part is put into every decoder in the decoder part. source: http://jalammar.github.io/illustrated-transformer/ }}{20}{figure.1.14}% 
\contentsline {figure}{\numberline {1.15}{\ignorespaces Figure from \citep {Ruder2019} offers possible taxonomy for transfer learning. Following definiton in \citep {Pan2009}, transfer learning's goal is to improve the performance on task $T_1$ from domain $D_1$ by learning knowledge on task $T_0$ from domain $D_0$. Domain is defined as $D = {\chi ,P(X)}$, where $X \in \chi $, $\chi $ is a feature space and $P(X)$ is a marginal probability distribution over the feature space. Transfer learning allows the use of trained models on tasks with different sets of labels or different input data's nature. Input data can vary in the source they come from (wikipedia text versus a novel or a social network posts), they can learn from different features (e.g. different languages) or the distribution of classes is different than it was in the training data (so some highly presented classes in training data are rare in this new task and others are quite common but previously not seen too many times). }}{21}{figure.1.15}% 
\contentsline {figure}{\numberline {1.16}{\ignorespaces Input is representing using tree kinds of embeddings for every input word. Every sequence is also decorated by beggining and ending marker (CLS and SEP token), which are also encoded using a combination of all three embedding types. Source: \textit {\citep {Devlin2019}}.}}{24}{figure.1.16}% 
\contentsline {figure}{\numberline {1.17}{\ignorespaces This figure illustrates a transformation of one input sentence (from PDT3) to suit bert input expectations. The sentence is divided into words and then into tokens from wordpiece tokenizer vocabulary. Accents may be removed depending on the used model. The sentence is decorated with special CLS and SEP tokens to mark the beginning and the end of the sentence. All tokens are then converted into numbers. }}{24}{figure.1.17}% 
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces }}{34}{figure.3.1}% 
\contentsline {figure}{\numberline {3.2}{\ignorespaces }}{35}{figure.3.2}% 
\contentsline {figure}{\numberline {3.3}{\ignorespaces Normalized confusion matrix}}{36}{figure.3.3}% 
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
